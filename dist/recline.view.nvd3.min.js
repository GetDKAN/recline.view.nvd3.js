;(function ($, my) {
  'use strict';

  my.ChartOptionsView = Backbone.View.extend({
    template: '<div class="col-md-12" id="chart-with-controls">' +
                '<div class="col-md-7">' +
                  '<ul class="nav nav-tabs" role="tablist" id="myTab">' +
                    '<li role="presentation" class="active"><a href="#chart-tab" aria-controls="home" role="tab" data-toggle="tab">Chart</a></li>' +
                    '<li role="presentation"><a href="#dataset-tab" aria-controls="settings" role="tab" data-toggle="tab">Dataset</a></li>' +
                  '</ul>' +
                  '<div class="tab-content">' +
                    '<div role="tabpanel" class="tab-pane active" id="chart-tab">' +
                      '<div  id="chart-viewport"></div>' +
                    '</div>' +
                    '<div role="tabpanel" class="tab-pane" id="dataset-tab">' +
                      '<div id="pager"></div>' +
                      '<div id="grid"></div>' +
                    '</div>' +
                  '</div>' +
                '</div>' +
                '<div class="col-md-5" id="controls">' +
                  '<div id="base-controls"></div>' +
                  '<div id="extended-controls"></div>' +
                '</div>' +
              '</div>' +
              '<div class="col-md-12" id="controls">' +
                '<div id="prev" class="btn btn-default pull-left">Back</div>' +
                '<button type="submit" class="form-submit btn btn-success pull-right">Finish</button>' +
              '</div>',
    initialize: function(options){
      var self = this;
      self.options = _.defaults(options || {}, self.options);
      self.state = self.options.state;
      self.stepInfo = {
        title: 'Preview and Adjust',
        name: 'chartOptions'
      };
    },
    render: function(){
      console.log('ChartOptionsView::render');
      var self = this;
      var graphType = self.state.get('graphType');

      self.$el.html(Mustache.render(self.template, self.state.toJSON()));

      // Common controls for all the charts.
      self.baseControls = new recline.View.nvd3.BaseControl({
        model: self.state.get('model'),
        state: self.state,
        parent: self
      });

      // Controls available only for this graphType.
      self.extendedControls = new recline.View.nvd3[graphType + 'Controls']({
        model: self.state.get('model'),
        state: self.state
      });

      // Chart itself.
      self.graph = new recline.View.nvd3[graphType]({
        model: self.state.get('model'),
        state: self.state
      });
      // Grid
      self.grid = new recline.View.SlickGrid({
        model: self.state.get('model'),
        el: $('#grid'),
        options:{}
      });
      self.grid.visible = true;

      self.assign(self.graph, '#chart-viewport');
      self.assign(self.baseControls, '#base-controls');
      self.assign(self.extendedControls, '#extended-controls');
      self.assign(self.grid, '#grid');

      // Slickgrid needs to update after tab content is displayed
      $('#grid')
        .closest('.tab-content')
        .prev()
        .find('a[data-toggle="tab"]')
        .on('shown.bs.tab', function () {
          self.grid.grid.resizeCanvas();
        });

      self.$('.chosen-select').chosen({width: '95%'});
    },
    updateState: function(state, cb){
      cb(state);
    },
    assign: function(view, selector){
      var self = this;
      view.setElement(self.$(selector)).render();
    },
  });

})(jQuery, window);;;(function ($, my) {
  'use strict';


  my.ChooseChartView = Backbone.View.extend({
    template: '<div class="form-group">' +
                '<ul id="chart-selector">' +
                  '{{#graphTypes}}' +
                    '<li class="{{value}} {{#selected}}selected{{/selected}}" data-selected="{{value}}"></li>' +
                  '{{/graphTypes}}' +
                '</ul>' +
              '</div>' +
              '<div id="controls">' +
                '<div id="prev" class="btn btn-default pull-left">Back</div>' +
                '<div id="next" class="btn btn-primary pull-right">Next</div>' +
              '</div>',
    initialize: function(options){
      var self = this;
      self.options = _.defaults(options || {}, self.options);
      self.state = self.options.state;
      self.stepInfo = {
        title: 'Choose Chart',
        name: 'chooseChart'
      };
    },
    events: {
      'click #chart-selector li': 'selectChart'
    },
    selectChart: function(e){
      var self = this;
      self.$('li').removeClass('selected');
      self.$(e.target).addClass('selected');
    },
    getSelected: function(){
      var self = this;
      return self.$('li.selected').data('selected');
    },
    render: function(){
      var self = this;
      var graphTypes = ['discreteBarChart', 'multiBarChart', 'stackedAreaChart', 'pieChart',
        'lineChart', 'lineWithFocusChart', 'scatterChart', 'linePlusBarChart'
      ];

      self.state.set('graphTypes', _.applyOption(
        _.arrayToOptions(graphTypes), [self.state.get('graphType') || 'discreteBarChart']
      ));
      self.$el.html(Mustache.render(self.template, self.state.toJSON()));
      self.$('.chosen-select').chosen({width: '95%'});
    },
    updateState: function(state, cb){
      var self = this;
      var type = self.getSelected();
      state.set('graphType', type);
      cb(state);
    }
  });

})(jQuery, window);;;(function ($, my) {
  'use strict';

  my.DataOptionsView = Backbone.View.extend({
    template: '<div class="form-group">' +
                  '<label for="control-chart-series">Series</label>' +
                  '<select id="control-chart-series" multiple class="form-control chosen-select">' +
                    '{{#fields}}' +
                      '<option value="{{value}}" {{#selected}} selected{{/selected}}>{{name}}</option>' +
                    '{{/fields}}' +
                  '</select>' +
                '</div>' +
                '<div class="form-group">' +
                  '<label for="control-chart-xfield">X-Field</label>' +
                  '<select id="control-chart-xfield" class="form-control chosen-select">' +
                    '{{#xfields}}' +
                      '<option value="{{value}}" {{#selected}} selected{{/selected}}>{{name}}</option>' +
                    '{{/xfields}}' +
                  '</select>' +
                '</div>' +
                '<div class="form-group">' +
                  '{{#xDataTypes}}' +
                    '<label class="radio-inline">' +
                      '<input type="radio" name="control-chart-x-data-type" id="control-chart-x-data-type-{{value}}" value="{{value}}" {{#selected}}checked {{/selected}}> {{name}}' +
                    '</label>' +
                  '{{/xDataTypes}}' +
                '</div>' +
                '<div id="controls">' +
                  '<div id="prev" class="btn btn-default pull-left">Back</div>' +
                  '<div id="next" class="btn btn-primary pull-right">Next</div>' +
                '</div>' +
              '</div>',
    initialize: function(options){
      var self = this;
      self.options = _.defaults(options || {}, self.options);
      self.state = self.options.state;
      self.stepInfo = {
        title: 'Define Variables',
        name: 'dataOptions'
      };
    },
    render: function(){
      var self = this;
      var dataTypes = ['Number', 'String', 'Date', 'Auto'];

      self.state.set('fields', _.applyOption(
        _.arrayToOptions(_.getFields(self.state.get('model'))), self.state.get('seriesFields')
      ));
      self.state.set('xfields', _.applyOption(
        _.arrayToOptions(_.getFields(self.state.get('model'))), [self.state.get('xfield')]
      ));
      self.state.set('xDataTypes', _.applyOption(
        _.arrayToOptions(dataTypes), [self.state.get('xDataType') || 'Auto']
      ));

      self.$el.html(Mustache.render(self.template, self.state.toJSON()));
      self.$('.chosen-select').chosen({width: '95%'});
    },
    updateState: function(state, cb){
      var self = this;
      state.set('seriesFields', self.$('#control-chart-series').val());
      state.set('xfield', self.$('#control-chart-xfield').val());
      state.set('xDataType', self.$('input[name=control-chart-x-data-type]:checked').val());
      cb(state);
    }
  });

})(jQuery, window);;;(function ($, my) {
  'use strict';

  my.LoadDataView = Backbone.View.extend({
    template: '<div class="form-group">' +
                '<label for="control-chart-source">Source</label>' +
                '<input value="{{source.url}}" type="text" id="control-chart-source" class="form-control" />' +
              '</div>' +
              '<div id="controls">' +
                '<div id="next" class="btn btn-primary pull-right">Next</div>' +
              '</div>',
    initialize: function(options){
      var self = this;
      self.options = _.defaults(options || {}, self.options);
      self.state = self.options.state;
      self.model = self.options.model;
      self.stepInfo = {
        title: 'Load Data',
        name: 'loadData'
      };
    },
    render: function(){
      var self = this;
      self.$el.html(Mustache.render(self.template, self.state.toJSON()));
    },
    updateState: function(state, cb){
      var self = this;
      var url = self.$('#control-chart-source').val();
      var source = {
        backend: 'csv',
        url: url
      };
      state.set('model', new recline.Model.Dataset(source));
      state.set('source', source);
      state.get('model').fetch().done(function(){
        cb(state);
      });
    }
  });

})(jQuery, window);;;(function ($, my) {
  'use strict';

  my.MultiStageView = Backbone.View.extend({
    template: '<h3>{{title}}</h3>' +
              '<input type="hidden" value="{{state}}"/>' +
              '<div id="step"></div>',
    events:{
      'click #next': 'nextStep',
      'click #prev': 'prevStep'
    },
    initialize: function(options){
      var self = this;
      self.options = _.defaults(options || {}, self.options);
      self.state = self.options.state;
      self._currentView = null;
      self.currentStep = self.state.get('step') || 0;
      self.steps = [];

      self.state.set('step', self.currentStep);
    },
    render: function(){
      var self = this;
      self.currentView = self.getStep(self.currentStep);
      _.extend(self.currentView.stepInfo, {state:JSON.stringify(self.state.toJSON())});
      self.$el.html(Mustache.render(self.template, self.currentView.stepInfo));

      self.assign(self.currentView, '#step');
      return self;
    },
    assign: function(view, selector){
      var self = this;
      view.setElement(self.$(selector)).render();
    },
    addStep: function(view){
      var self = this;
      self.steps.push(view);
    },
    getStep: function(index){
      var self = this;
      return self.steps[index];
    },
    nextStep: function(){
      var self = this;
      var toNext = self.updateStep(self.getNext(self.steps, self.currentStep));
      self.currentView.updateState(self.state, toNext);
    },
    prevStep: function(){
      var self = this;
      var toPrev = self.updateStep(self.getPrev(self.steps, self.currentStep));
      self.currentView.updateState(self.state, toPrev);
    },
    getNext: function(steps, current){
      var limit = steps.length - 1;
      if(limit === current){
        return current;
      }
      return ++current;
    },
    getPrev: function(steps, current){
      if(current){
        return --current;
      }
      return current;
    },
    updateStep: function(n){
      var self = this;
      return function(state){
        self.state = state;
        self.gotoStep(n);
        self.trigger('multistep:change', {step:n});
      };
    },
    gotoStep: function(n){
      var self = this;
      self.currentStep = n;
      self.state.set('step', self.currentStep);
      self.render();
    }
  });

})(jQuery, window);;;(function ($, my) {
  'use strict';

  my.PublishView = Backbone.View.extend({
    template: '<div class="col-md-12" id="chart-with-controls">' +
                '<div class="col-md-7">' +
                  '<div  id="chart-viewport"></div>' +
                '</div>' +
                '<div class="col-md-5" id="controls">' +
                  '<div id="embed-control"></div>' +
                '</div>' +
              '</div>' +
              '<div class="col-md-12" id="controls">' +
                '<div id="prev" class="btn btn-default pull-left">Back</div>' +
                '<div id="next" class="btn btn-success pull-right">Publish</div>' +
              '</div>',
    initialize: function(options){
      var self = this;
      self.options = _.defaults(options || {}, self.options);
      self.state = self.options.state;
      self.stepInfo = {
        title: 'Publish and Share',
        name: 'publish'
      };
    },
    render: function(){
      console.log('ChartOptionsView::render');
      var self = this;
      var graphType = self.state.get('graphType');

      self.$el.html(Mustache.render(self.template, self.state.toJSON()));

      // Common controls for all the charts.
      self.embedControl = new recline.View.nvd3.EmbedControl({
        model: self.state.get('model'),
        state: self.state,
        parent: self
      });

      // Chart itself.
      self.graph = new recline.View.nvd3[graphType]({
        model: self.state.get('model'),
        state: self.state
      });

      self.assign(self.graph, '#chart-viewport');
      self.assign(self.embedControl, '#embed-control');

      self.$('.chosen-select').chosen({width: '95%'});
    },
    updateState: function(state, cb){
      cb(state);
    },
    assign: function(view, selector){
      var self = this;
      view.setElement(self.$(selector)).render();
    },
  });

})(jQuery, window);;/*jshint multistr:true*/

this.recline = this.recline || {};

;(function($, my) {
  'use strict';

  /**
   * Router object
   * @param {recline.ObjectState} state
   * @param {Object} first
   */
  my.URLState = function(options){
    var self = this;
    var parser;
    var dependencies = {};
    var router;
    self.currentState = {};

    options = options || {};
    if(options.parser) {
      parser = new options.parser();
    } else {
      parser = new my.Parser();
    }


    function inv(method){
      var args = _.rest(_.toArray(arguments));
      return function(ctrl){
        return _.isFunction(ctrl[method]) && ctrl[method].apply(ctrl, args);
      };
    }

    /**
     * Init first state
     * @param  {[String]} serializedState Url serialized state
     */
    self._init = function(serializedState){
      var state = self.transform(serializedState, self.toState);
      _.each(dependencies, inv('update', state));
      self.currentState = state;
      if(options.init){
        options.init(state);
      }
    };


    /**
     * Adds a dependency to this router. Something to track and
     * to execute when tracked thing changes
     * @param  {Function} ctrl Constructor with the implementation
     * of this observer
     * @return {undefined}
     */
    self.addDependency = function(ctrl){
      dependencies[ctrl.name] = ctrl;
    };


    self.getCurrentState = function(){
      return self.currentState;
    };

    self.getSerializedState = function(state){
      return self.transform(state, self.toParams);
    };
    /**
     * Applies a transform function to the input and return de result.
     * @param  {String} input
     * @param  {Function} transformFunction
     * @return {String}
     */
    self.transform = function(input, transformFunction){
      var result;
      // try{
        result = transformFunction(input);
      // } catch(e){
      //   result = null;
      // }
      return result;
    };

    /**
     * Converts a serialized state string to an object.
     * @param  {String} serializedState
     * @return {Object}
     */
    self.toState = function(serializedState){
      var stringObject = parser.inflate(decodeURI(serializedState));
      return JSON.parse(stringObject);
    };

    /**
     * Converts an object state to a string.
     * @param  {Object} state
     * @return {String}
     */
    self.toParams = function(state){
      var stringObject = JSON.stringify(state);
      return parser.compress(stringObject);
    };

    /**
     * Listen for changes in the state. It computes the differences
     * between the initial state and the current state. Creates a patch object
     * from this difference. Converts this new object to params and finally
     * navigates to that state.
     * @param  {Event} event
     */
    self.navigateToState = function(state){
      self.currentState = state;
      router.navigate(self.transform(state, self.toParams));
      options.stateChange && options.stateChange(state); // jshint ignore:line
    };

    var Router = Backbone.Router.extend({
      routes: {
        '*state': 'defaultRoute',
      },
      defaultRoute: self._init
    });
    router = new Router();
    Backbone.history.start();
  };

  /**
   * Url parser
   */
  my.Parser = function(){
    var self = this;

    /**
     * Reduces the size of the url removing unnecesary characters.
     * @param  {String} str
     * @return {String}
     */
    self.compress = function(str){

      // Replace words
      // Remove start and end brackets
      // Replace true by 1 and false by 0
      return self.escapeStrings(str);
    };

    /**
     * Inflates a compressed url string.
     * @param  {String} str
     * @return {String}
     */
    self.inflate = function(str){
      return self.parseStrings(str);
    };

    /**
     * Escape all the string prepending a ! character to each one.
     * @param  {String} str
     * @return {String}
     */
    self.escapeStrings = function(str){

      // % presence could lead to malformed url.
      str = str.replace('%', '@@');

      // Stripping quotes from keys
      str = str.replace(/"([a-zA-Z-_.]+)"\s?:/g ,  '$1:');

      // Replacing spaces between quotes with underscores
      str = str.replace(/\x20(?![^"]*("[^"]*"[^"]*)*$)/g, '++');
      return str.replace(/"([a-zA-Z0-9-#_.-|+]+)?"/g ,  '!$1');
    };

    /**
     * Converts all escaped strings to javascript strings.
     * @param  {String} str
     * @return {String}
     */
    self.parseStrings = function(str){

      // Converting all the @@ to %.
      str = str.replace('@@', '%');

      // Adding quotes to keys
      str = str.replace(/([{,])([a-zA-Z-_.\+]+)\s?:/g ,  '$1\"$2\":');
      // Replacing underscores with spaces for any word that start with !
      // TODO: make space replacement configurable
      str = str.replace(/![a-zA-Z0-9_. -\+]+/g, function(x) {
        return x.replace(/\+\+/g, ' ');
      });
      return str.replace(new RegExp('!([a-zA-Z0-9-_# .-:%]+)?', 'g'),  '\"$1\"');
    };
  };

})(jQuery, this.recline);;/*jshint multistr:true */

this.recline = this.recline || {};
this.recline.View = this.recline.View || {};
this.recline.View.nvd3 = this.recline.View.nvd3 || {};

;(function ($, my) {
  'use strict';

  var DEFAULT_CHART_WIDTH = 640;
  var DEFAULT_CHART_HEIGHT = 480;

  function makeId(prefix) {
      prefix = prefix || '';
      return prefix + (Math.random() * 1e16).toFixed(0);
  }

  my.Base = Backbone.View.extend({
      template:'<div class="recline-graph row">' +
                  '{{data}}' +
                  '<div class="{{columnClass}} {{viewId}}"style="display: block;">' +
                    '<div id="{{viewId}}">' +
                        '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" ' +
                        ' height="{{height}}" width="{{width}}">' +
                        '</svg>' +
                    '</div>' +
                  '</div>' +
                '</div> ',
      initialize: function(options) {
        var self = this;
        self.$el = $(self.el);

        self.options = _.defaults(options || {}, self.options);

        var stateData = _.merge({
            width: 640,
            height: 480,
            group: false,
          },
          self.getDefaults(),
          self.options.state.toJSON()
        );

        self.graphType = self.graphType || 'multiBarChart';
        self.uuid = makeId('nvd3chart_');
        self.state = self.options.state;
        self.state.set(stateData);
        self.chartMap = d3.map();
        self.state.listenTo(self.state, 'change', self.render.bind(self));
      },
      getLayoutParams: function(){
        var self = this;
        var layout = {
          columnClass: 'col-md-12',
          width: self.state.get('width') || self.$el.innerWidth() || DEFAULT_CHART_WIDTH,
          height: self.state.get('height') || DEFAULT_CHART_HEIGHT
        };
        return layout;
      },
      render: function(){
        var self = this;
        var tmplData;
        var htmls;
        var layout;

        layout = self.getLayoutParams();
        tmplData = self.model.toTemplateJSON();
        tmplData.viewId = self.uuid;

        _.extend(tmplData, layout);

        htmls = Mustache.render(self.template, tmplData);
        self.$el.html(htmls);
        self.$graph = self.$el.find('.panel.' + tmplData.viewId);
        self.trigger('chart:endDrawing');
        self.series = self.createSeries(self.model.records);
        nv.addGraph(function() {
          self.chart = self.createGraph(self.graphType);

          if(self.chart.xAxis && self.chart.xAxis.tickFormat)
            self.chart.xAxis.tickFormat(self.xFormatter);
          if(self.chart.x2Axis)
            self.chart.x2Axis.tickFormat(self.xFormatter);

          var computeXLabels = self.needForceX(self.model.records, self.graphType);
          self.state.set('computeXLabels', computeXLabels, {silent:true});

          self.chart.yAxis && self.chart.yAxis.axisLabelDistance(30); // jshint ignore:line

          d3.select('#' + self.uuid + ' svg')
            .datum(self.series)
            .transition()
            .duration(self.state.get('transitionTime') || 500)
            .call(self.chart);

          // Hack to reduce ticks even if the chart has not that option.
          if(self.graphType === 'discreteBarChart' && self.state.get('options') && self.state.get('options').reduceXTicks){
            self.reduceXTicks();
          }

          nv.utils.windowResize(self.updateChart.bind(self));
          return self.chart;
        });
        return self;
      },
      lightUpdate: function(){
        var self = this;
        self.series = self.createSeries(self.model.records);
        d3.select('#' + self.uuid + ' svg')
          .datum(self.series)
          .transition()
          .duration(500)
          .call(self.chart);
      },
      updateChart: function(){
        var self = this;
        d3.select('#' + self.uuid + ' svg')
          .transition()
          .duration(self.state.get('transitionTime') || 500)
          .call(self.chart);
      },
      reduceXTicks: function(){
        var self = this;
        var layout = self.getLayoutParams(self.state.get('mode'));
        d3.select('.nv-x.nv-axis > g').selectAll('g')
          .filter(function(d, i) {
              return i % Math.ceil(self.model.records.length / (layout.width / 100)) !== 0;
          })
          .selectAll('text, line')
          .style('opacity', 0);
      },
      createSeries: function(records){
        var self = this;
        var series;
        var fieldType;
        var xDataType;

        // Return no data when x and y are no set.
        if(!self.state.get('xfield') || !self.getSeries()) return [];

        records = records.toJSON();

        fieldType = _.compose(_.inferType,_.iteratee(self.state.get('xfield')));

        if(!self.state.get('xDataType') || self.state.get('xDataType') === 'Auto'){
          xDataType =  fieldType(_.last(records));
        } else {
          xDataType = self.state.get('xDataType');
        }

        self.xFormatter = self.getFormatter(xDataType, self.state.get('xFormat'));

        series = _.map(self.getSeries(), function(serie){
          var data = {};
          data.key = serie;

          // Group by xfield and acum all the series fields.
          records = (self.state.get('group'))?
            _.reportBy(records, self.state.get('xfield'), self.state.get('seriesFields'))
            : records;

          records = _.sortBy(records, self.state.get('sort') || self.state.get('xfield'));

          data.values = _.map(records, function(record, index){
            if(self.state.get('computeXLabels')){
              self.chartMap.set(index, self.x(record, self.state.get('xfield')));
              return {y: self.y(record, serie), x: index, label: self.x(record, self.state.get('xfield'))};
            } else {
              return {
                y: self.y(record, serie),
                x: _.cast(self.x(record, self.state.get('xfield')), xDataType)
              };
            }
          });
          return data;
        });
        return series;
      },
      needForceX: function(records, graphType){
       var self = this;
       var xfield = self.state.get('xfield');
       records = records.toJSON();
       return _.some(records, function(record){
         return _.inferType(record[xfield]) === 'String';
       }) && graphType !== 'discreteBarChart' && graphType !== 'multiBarChart';
      },
      getFormatter: function(type, format){
        var self = this;
        if(self.state.get('computeXLabels')) return self.chartMap.get.bind(self.chartMap);

        var formatter = {
          'String': _.identity,
          'Date': _.compose(d3.time.format(format || '%x'),_.instantiate(Date)),
          'Number': d3.format(format || '.02f')
        };

        return formatter[type];
      },
      setOptions: function (chart, options) {
        var self = this;
        for(var optionName in options){
          var optionValue = options[optionName];
          if(_.isObject(optionValue) && !_.isArray(optionValue)){
            self.setOptions(chart[optionName], optionValue);
          // if value is a valid function in the chart then we call it.
          } else if(chart && _.isFunction(chart[optionName])){
            chart[optionName](optionValue);
          }
        }
      },
      createGraph: function(graphType){
        var self = this;
        var chart = nv.models[graphType]();
        // Set each graph option recursively.
        self.setOptions(chart, self.state.get('options'));
        return chart;
      },
      getDefaults: function(){
        return {};
      },
      getState: function(){
        var self = this;
        return self.state.attributes;
      },
      getSeries: function(){
        var self = this;
        return self.state.get('seriesFields');
      },
      x: function(record, xfield){
        return record[xfield];
      },
      y: function(record, serie){
        return record[serie];
      }
  });

})(jQuery, recline.View.nvd3);;/*jshint multistr:true */

this.recline = this.recline || {};
this.recline.View = this.recline.View || {};

;(function ($, my) {
'use strict';
my.BaseControl = Backbone.View.extend({
  template: '<div id="control-chart-container">' +
              '<div class="form-group">' +
                '<label for="control-chart-x-format">X-Format</label>' +
                '<input value="{{xFormat}}" type="text" id="control-chart-x-format" class="form-control" />' +
              '</div>' +
              '<div class="form-group">' +
                '<label for="control-chart-label-x-rotation">Label X Rotation</label>' +
                '<input value="{{options.xAxis.rotateLabels}}" type="text" id="control-chart-label-x-rotation" class="form-control" />' +
              '</div>' +
              '<div class="form-group">' +
                '<label for="control-chart-transition-time">Transition Time</label>' +
                '<input value="{{transitionTime}}" type="text" id="control-chart-transition-time" class="form-control" />' +
              '</div>' +
              '<div class="form-group">' +
                  '<label for="control-chart-color">Color</label>' +
                  '<input class="form-control" type="text" id="control-chart-color" value="{{options.color}}"/>' +
              '</div>' +
              '<div class="form-group">' +
                  '<label for="control-chart-x-axis-label">X Axis Label</label>' +
                  '<input class="form-control" type="text" id="control-chart-x-axis-label" value="{{options.xAxis.axisLabel}}"/>' +
              '</div>' +
              '<div class="form-group">' +
                  '<label for="control-chart-x-axis-label">Y Axis Label</label>' +
                  '<input class="form-control" type="text" id="control-chart-y-axis-label" value="{{options.yAxis.axisLabel}}"/>' +
              '</div>' +
              '<div class="form-group checkbox">' +
                '<label for="control-chart-group">' +
                  '<input type="checkbox" id="control-chart-group" value="{{group}}" {{#group}}checked{{/group}}/> Group by X-Field' +
                '</label>' +
              '</div>' +
              '<div class="form-group checkbox">' +
                '<label for="control-chart-show-tooltips">' +
                  '<input type="checkbox" id="control-chart-show-tooltips" {{#options.tooltips}}checked{{/options.tooltips}}/> Show Tooltips' +
                '</label>' +
              '</div>' +
              '<div class="form-group checkbox">' +
                '<label for="control-chart-reduce-ticks">' +
                  '<input type="checkbox" id="control-chart-reduce-ticks" {{#options.reduceXTicks}}checked{{/options.reduceXTicks}}/> Reduce Ticks' +
                '</label>' +
              '</div>' +
            '</div>',

  initialize: function(options){
    var self = this;
    self.state = options.state;
    self.model = options.model;
    self.parent = options.parent;
  },
  events: {
    'change input[type="checkbox"]': 'update',
    'blur input[type="text"]': 'update',
    'keydown input[type="text"]': 'update',
    'submit #control-chart': 'update'
  },
  render: function(){
    var self = this;
    self.$el.html(Mustache.render(self.template, self.state.toJSON()));
    self.$('.chosen-select').chosen({width: '95%'});
  },
  update: function(e){
    var self = this;
    var newState = {};
    if(e.type === 'keydown' && e.keyCode !== 13) return;
    newState = _.merge({}, self.state.toJSON(), self.getUIState());
    self.state.set(newState);
  },
  getUIState: function(){
    var self = this;
    var color;

    var computedState = {
      group: $('#control-chart-group').is(':checked'),
      transitionTime: $('#control-chart-transition-time').val(),
      xFormat: $('#control-chart-x-format').val()
    };
    computedState.options = computedState.options || {};
    computedState.options.xAxis = computedState.options.xAxis || {};
    computedState.options.yAxis = computedState.options.yAxis || {};
    computedState.options.tooltips = self.$('#control-chart-show-tooltips').is(':checked');
    computedState.options.reduceXTicks = self.$('#control-chart-reduce-ticks').is(':checked');
    computedState.options.xAxis.rotateLabels = self.$('#control-chart-label-x-rotation').val();
    color = _.invoke(self.$('#control-chart-color').val().split(','), 'trim');
    computedState.options.xAxis.axisLabel = $('#control-chart-x-axis-label').val();
    computedState.options.yAxis.axisLabel = $('#control-chart-y-axis-label').val();
    if(self.$('#control-chart-color').val()){
      computedState.options.color = color;
    } else {
      if(computedState.options.color){
        console.log('deleting');
        delete computedState.options.color;
      }
    }
    return computedState;
  }
});

})(jQuery, recline.View.nvd3);;/*jshint multistr:true */

this.recline = this.recline || {};
this.recline.View = this.recline.View || {};

;(function ($, my) {
'use strict';

  my.cumulativeLineChart = recline.View.nvd3.Base.extend({
    initialize: function(options) {
      var self = this;
      self.graphType = 'cumulativeLineChart';
      recline.View.nvd3.Base.prototype.initialize.call(self, options);
    },
    render: function(){
      var self = this;
      recline.View.nvd3.Base.prototype.render.call(self, {});
    },
    createSeries: function(records){
      var self = this;
      records = records.toJSON();
      self.chartMap = d3.map();

      return _.map(self.state.get('seriesFields'), function(serie){
        var data = {};
        data.key = serie;
        data.values = _.map(records, function(record, index){
          self.chartMap.set(index, self.x(record));
          return {y: self.y(record, serie), x: index, label: self.x(record)};
        });
        return data;
      });
    },
    getDefaults: function(){
      var self = this;
      return {
        options:{
          useInteractiveGuideline: true,
          tooltips: true,
          xAxis:{
            tickFormat: function(id) {
              return (self.chartMap) ? self.chartMap.get(id) : id;
            }
          }
        }
      };
    }
  });

  my.cumulativeLineChartControls = recline.View.nvd3.BaseControl.extend({});
})(jQuery, recline.View.nvd3);;/*jshint multistr:true */

this.recline = this.recline || {};
this.recline.View = this.recline.View || {};

;(function ($, my) {
'use strict';

  my.discreteBarChart = recline.View.nvd3.Base.extend({
    initialize: function(options) {
      var self = this;
      self.graphType = 'discreteBarChart';
      recline.View.nvd3.Base.prototype.initialize.call(self, options);
    },
    render: function(){
      var self = this;
      recline.View.nvd3.Base.prototype.render.call(self, {});
    },
    getDefaults: function(){
      return {
        computeXLabels: false,
        options:{
          tooltips: true
        }
      };
    }
  });

  my.discreteBarChartControls = recline.View.nvd3.BaseControl.extend({
    template: '<div class="form-group checkbox">' +
                  '<label for="control-chart-stagger-labels">' +
                    '<input type="checkbox" id="control-chart-stagger-labels" {{#options.staggerLabels}}checked{{/options.staggerLabels}}/> Stagger Labels' +
                  '</label>' +
              '</div>' +
              '<div class="form-group checkbox">' +
                '<label for="control-chart-show-values">' +
                  '<input type="checkbox" id="control-chart-show-values" {{#options.showValues}}checked{{/options.showValues}}/> Show Values' +
                '</label>' +
              '</div>',
    events: {
      'change input[type="checkbox"]': 'update',
    },
    getUIState:function(){
      var self = this;
      var computedState = {options: {}};
      computedState.options.showValues = self.$('#control-chart-show-values').is(':checked');
      computedState.options.staggerLabels = self.$('#control-chart-stagger-labels').is(':checked');
      return computedState;
    }
  });
})(jQuery, recline.View.nvd3);;/*jshint multistr:true */

this.recline = this.recline || {};
this.recline.View = this.recline.View || {};

;(function ($, my) {
 'use strict';

  my.EmbedControl = recline.View.nvd3.BaseControl.extend({
    template: '<div class="form-group">' +
                '<label for="control-chart-width">Width</label>' +
                '<input value="{{width}}" type="text" id="control-chart-width" class="form-control" />' +
              '</div>' +
              '<div class="form-group">' +
                '<label for="control-chart-height">Height</label>' +
                '<input value="{{height}}" type="text" id="control-chart-height" class="form-control" />' +
              '</div>' +
              '<div class="form-group">' +
                '<input type="hidden" value="{{serialized}}" class="form-control"/>' +
              '</div>' +
              '<div class="form-group">' +
                '<label for="control-chart-embed">Embed Code</label>' +
                '<input value="{{embedCode}}" class="form-control"/>' +
              '</div>' +
              '<div class="form-group">' +
                '<label for="control-chart-embed">Url</label>' +
                '<input value="{{url}}" class="form-control"/>' +
              '</div>',
    embedTmpl: '<iframe src="{{{source}}}" width="{{width}}" height="{{height}}" frameBorder="0" style="overflow:hidden" scrolling="no"></iframe>',
    events: {
      'change input[type="checkbox"]': 'update',
      'blur input[type="text"]': 'update',
      'keydown input[type="text"]': 'update',
    },
    update: function(e){
      var self = this;
      var newState = {};
      if(e.type === 'keydown' && parseInt(e.keyCode) !== 13) return;
      newState = _.merge({}, self.state.toJSON(), self.getUIState());
      self.state.set(newState, {silent:true});
    },
    getUIState:function(){
      var self = this;
      var computedState = {
        width: self.$('#control-chart-width').val(),
        height: self.$('#control-chart-height').val(),
      };
      return computedState;
    }
  });
})(jQuery, recline.View.nvd3);;/*jshint multistr:true */

this.recline = this.recline || {};
this.recline.View = this.recline.View || {};

;(function ($, my) {
  'use strict';

  my.lineChart = recline.View.nvd3.Base.extend({
    initialize: function(options) {
      var self = this;
      self.graphType = 'lineChart';
      recline.View.nvd3.Base.prototype.initialize.call(self, options);
      self.state.set('computeXLabels', true);
    },
    render: function(){
      var self = this;
      recline.View.nvd3.Base.prototype.render.call(self, {});
    },
    getDefaults: function(){
      var self = this;
      return {
        options: {
          useInteractiveGuideline: true,
          tooltips: true,
          xAxis:{
            tickFormat: function(id) {
              return (self.chartMap) ? self.chartMap.get(id) : id;
            }
          }
        }
      };
    }
  });

  my.lineChartControls = recline.View.nvd3.BaseControl.extend({
    template: '<div class="form-group checkbox">' +
                '<label for="control-chart-compute-x-labels">' +
                '<input type="checkbox" id="control-chart-compute-x-labels" {{#computeXLabels}}checked{{/computeXLabels}}/> X values as labels' +
                '</label>' +
              '</div>',
    events: {
      'change input[type="checkbox"]': 'update',
    },
    getUIState:function(){
      var self = this;
      var computedState = {options: {}};
      computedState.computeXLabels = self.$('#control-chart-compute-x-labels').is(':checked');
      return computedState;
    }
  });


})(jQuery, recline.View.nvd3);;/*jshint multistr:true */

this.recline = this.recline || {};
this.recline.View = this.recline.View || {};

;(function ($, my) {
  'use strict';

  my.lineWithFocusChart = recline.View.nvd3.Base.extend({
    initialize: function(options) {
      var self = this;
      self.graphType = 'lineWithFocusChart';
      recline.View.nvd3.Base.prototype.initialize.call(self, options);
      self.state.set('computeXLabels', true);
    },
    render: function(){
      var self = this;
      recline.View.nvd3.Base.prototype.render.call(self, {});
    },
    getDefaults: function(){
      var self = this;
      return {
        options: {
          tooltips: true,
          xAxis:{
            tickFormat: function(id) {
              return (self.chartMap) ? self.chartMap.get(id) : id;
            }
          }
        }
      };
    }
  });

  my.lineWithFocusChartControls = recline.View.nvd3.BaseControl.extend({
    template: '<div class="form-group checkbox">' +
                '<label for="control-chart-compute-x-labels">' +
                '<input type="checkbox" id="control-chart-compute-x-labels" {{#computeXLabels}}checked{{/computeXLabels}}/> X values as labels' +
                '</label>' +
              '</div>',
    events: {
      'change input[type="checkbox"]': 'update',
    },
    getUIState:function(){
      var self = this;
      var computedState = {options: {}};
      computedState.computeXLabels = self.$('#control-chart-compute-x-labels').is(':checked');
      return computedState;
    }
  });
})(jQuery, recline.View.nvd3);;/*jshint multistr:true */

this.recline = this.recline || {};
this.recline.View = this.recline.View || {};

;(function ($, my) {
  'use strict';

  my.multiBarChart = recline.View.nvd3.Base.extend({
    initialize: function(options) {
      var self = this;
      self.graphType = 'multiBarChart';
      recline.View.nvd3.Base.prototype.initialize.call(self, options);
    },
    render: function(){
      var self = this;
      recline.View.nvd3.Base.prototype.render.call(self, {});

    },
    getDefaults: function(){
      return {
        computeXLabels: false,
        options:{
          reduceXTicks: true,
          tooltips: true
        }
      };
    }
  });

  my.multiBarChartControls = recline.View.nvd3.BaseControl.extend({
    template: '<div class="form-group checkbox">' +
                '<label for="control-chart-stagger-labels">' +
                '<input type="checkbox" id="control-chart-stagger-labels" {{#options.staggerLabels}}checked{{/options.staggerLabels}}/> Stagger Labels' +
                '</label>' +
              '</div>',
    events: {
      'change input[type="checkbox"]': 'update',
    },
    getUIState:function(){
      var self = this;
      var computedState = {options: {}};
      computedState.computeXLabels = self.$('#control-chart-compute-x-labels').is(':checked');
      computedState.options.staggerLabels = self.$('#control-chart-stagger-labels').is(':checked');
      return computedState;
    }

  });

})(jQuery, recline.View.nvd3);;/*jshint multistr:true */

this.recline = this.recline || {};
this.recline.View = this.recline.View || {};

;(function ($, my) {
  'use strict';

  my.multiBarHorizontalChart = recline.View.nvd3.Base.extend({
    initialize: function(options) {
      var self = this;
      self.graphType = 'multiBarHorizontalChart';
      recline.View.nvd3.Base.prototype.initialize.call(self, options);
      self.state.set('computeXLabels', false);
    },
    render: function(){
      var self = this;
      recline.View.nvd3.Base.prototype.render.call(self, {});
    },
    getDefaults: function(){
      return {
        options: {
          tooltips: true,
          reduceXTicks: false,
        }
      };
    }
  });

  my.multiBarHorizontalChartControls = recline.View.nvd3.BaseControl.extend({
    template: '<div class="form-group checkbox">' +
                '<label for="control-chart-compute-x-labels">' +
                '<input type="checkbox" id="control-chart-compute-x-labels" {{#computeXLabels}}checked{{/computeXLabels}}/> X values as labels' +
                '</label>' +
              '</div>',
    events: {
      'change input[type="checkbox"]': 'update',
    },
    getUIState:function(){
      var self = this;
      var computedState = {options: {}};
      computedState.computeXLabels = self.$('#control-chart-compute-x-labels').is(':checked');
      return computedState;
    }
  });
})(jQuery, recline.View.nvd3);;/*jshint multistr:true */

this.recline = this.recline || {};
this.recline.View = this.recline.View || {};

;(function ($, my) {
  'use strict';

  my.pieChart = recline.View.nvd3.Base.extend({
    initialize: function(options) {
      var self = this;
      self.graphType = 'pieChart';
      recline.View.nvd3.Base.prototype.initialize.call(self, options);
    },
    render: function(){
      var self = this;
      recline.View.nvd3.Base.prototype.render.call(self, {});
    },
    createSeries: function(records){
      var self = this;
      records = records.toJSON();
      var serie = _.first(self.state.get('seriesFields'));
      // Group by xfield and acum all the series fields.
      records = (self.state.get('group'))?
        _.reportBy(records, self.state.get('xfield'), self.state.get('seriesFields'))
        : records;
      return  _.map(records, function(record){
        return {y: self.y(record, serie), x: self.x(record, self.state.get('xfield'))};
      });
    },
    getDefaults: function(){
      return {
        options: {
          showLabels: true,
          labelType: 'percent',
          tooltips:true
        }
      };
    }
  });

  my.pieChartControls = recline.View.nvd3.BaseControl.extend({
    template:'<div class="form-group checkbox">' +
                  '<label for="control-chart-donut">' +
                  '<input type="checkbox" id="control-chart-donut" {{#options.donut}}checked{{/options.donut}}/> Donut' +
                  '</label>' +
              '</div>',
    events: {
      'change input[type="checkbox"]': 'update',
    },
    getUIState:function(){
      var self = this;
      var computedState = {options: {}};
      computedState.options.donut = self.$('#control-chart-donut').is(':checked');
      return computedState;
    }

  });
})(jQuery, recline.View.nvd3);;/*jshint multistr:true */

this.recline = this.recline || {};
this.recline.View = this.recline.View || {};

;(function ($, my) {
  'use strict';

  my.scatterChart = recline.View.nvd3.Base.extend({
    initialize: function(options) {
      var self = this;
      self.graphType = 'scatterChart';
      recline.View.nvd3.Base.prototype.initialize.call(self, options);
      self.state.set('computeXLabels', true);
    },
    render: function(){
      var self = this;
      recline.View.nvd3.Base.prototype.render.call(self, {});
    },
    getDefaults: function(){
      var self = this;
      return {
        options: {
          showDistX: true,
          showDistY: true,
          onlyCircles: false,
          xAxis:{
            tickFormat: function(id) {
              return (self.chartMap) ? self.chartMap.get(id) : id;
            }
          }
        }
      };
    }
  });

  my.scatterChartControls = recline.View.nvd3.BaseControl.extend({
    template: '<div class="form-group checkbox">' +
                '<label for="control-chart-compute-x-labels">' +
                '<input type="checkbox" id="control-chart-compute-x-labels" {{#computeXLabels}}checked{{/computeXLabels}}/> X values as labels' +
                '</label>' +
              '</div>',
    events: {
      'change input[type="checkbox"]': 'update',
    },
    getUIState:function(){
      var self = this;
      var computedState = {options: {}};
      computedState.computeXLabels = self.$('#control-chart-compute-x-labels').is(':checked');
      return computedState;
    }
  });
})(jQuery, recline.View.nvd3);;/*jshint multistr:true */

this.recline = this.recline || {};
this.recline.View = this.recline.View || {};

;(function ($, my) {
  'use strict';

  my.stackedAreaChart = recline.View.nvd3.Base.extend({
    initialize: function(options) {
      var self = this;
      self.graphType = 'stackedAreaChart';
      recline.View.nvd3.Base.prototype.initialize.call(self, options);
      self.state.set('computeXLabels', true);
    },
    render: function(){
      var self = this;
      recline.View.nvd3.Base.prototype.render.call(self, {});
    },
    getDefaults: function(){
      return {
        options:{
          useInteractiveGuideline: true,
          tooltips: true,
          xAxis:{
            tickFormat: function(d) {
              return d3.time.format('%Y')(new Date(d));
              //return (self.chartMap) ? self.chartMap.get(id) : id;
            }
          }
        }
      };
    }
  });

  my.stackedAreaChartControls = recline.View.nvd3.BaseControl.extend({
    template:  '<div class="form-group checkbox">' +
                  '<label for="control-chart-compute-x-labels">' +
                    '<input type="checkbox" id="control-chart-compute-x-labels" {{#computeXLabels}}checked{{/computeXLabels}}/> Force x as labels' +
                  '</label>' +
                '</div>',
    events: {
      'change input[type="checkbox"]': 'update',
    },
    getUIState:function(){
      var self = this;
      var computedState = {options: {}};
      computedState.computeXLabels = self.$('#control-chart-compute-x-labels').is(':checked');
      return computedState;
    }
  });
})(jQuery, recline.View.nvd3);;jQuery(function(){
	'use strict';
	_.mixin({
	  getFields: function(model){
	    var fields = [];
	    try{
	      fields = _.pluck(model.fields.toJSON(), 'id');
	    } catch(err) {
	      console.error('Error retrieving dataset fields');
	    }
	    return fields;
	  },
		applyOption:function(options, selected){
			return _.map(options, function(option){
				option.selected = (_.inArray(selected, option.value))? true : false;
				return option;
			});
		},
		arrayToOptions: function(options){
			return _.map(options, function(option){
				return {name:option, value:option, selected: false};
			});
		},
	});
});
